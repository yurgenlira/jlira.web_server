# SPDX-License-Identifier: MIT-0
---
- name: Validate certificates_mode
  ansible.builtin.assert:
    that:
      - certificates_mode is defined
      - certificates_mode in ['selfsigned', 'import', 'letsencrypt']
    fail_msg: >-
      certificates_mode must be either 'selfsigned', 'import', or 'letsencrypt'.
      Current value: '{{ certificates_mode | default("undefined") }}'
    success_msg: "certificates_mode is valid: {{ certificates_mode }}"
    quiet: true

- name: Validate certificates_list is defined and is a list
  ansible.builtin.assert:
    that:
      - certificates_list is defined
      - certificates_list is iterable
      - certificates_list is not string
      - certificates_list is not mapping
    fail_msg: "certificates_list must be a list"
    success_msg: "certificates_list has {{ certificates_list | length }} certificate(s)"
    quiet: true

- name: Validate each certificate has a name
  ansible.builtin.assert:
    that:
      - item.name is defined
      - item.name is string
      - item.name | length > 0
    fail_msg: >-
      Each certificate must have a 'name' field.
      Invalid entry: {{ item }}
    success_msg: "Certificate '{{ item.name }}' has valid name"
    quiet: true
  loop: "{{ certificates_list }}"
  loop_control:
    label: "{{ item.name | default('unnamed') }}"
  when: certificates_list | length > 0

# ============================================================================
# Validation for selfsigned mode
# ============================================================================
- name: Validate selfsigned mode requirements
  when:
    - certificates_mode == 'selfsigned'
    - certificates_list | length > 0
  block:
    - name: Validate common_name is defined for selfsigned certificates
      ansible.builtin.assert:
        that:
          - item.common_name is defined
          - item.common_name is string
          - item.common_name | length > 0
        fail_msg: >-
          Certificate '{{ item.name }}' in selfsigned mode must have a 'common_name' field.
          Current value: '{{ item.common_name | default("undefined") }}'
        success_msg: "Certificate '{{ item.name }}' has valid common_name"
        quiet: true
      loop: "{{ certificates_list }}"
      loop_control:
        label: "{{ item.name }}"

    - name: Validate days is a positive integer if specified
      ansible.builtin.assert:
        that:
          - item.days | int > 0
          - item.days | int == item.days
        fail_msg: >-
          Certificate '{{ item.name }}' days must be a positive integer.
          Current value: '{{ item.days }}'
        success_msg: "Certificate '{{ item.name }}' days is valid"
        quiet: true
      loop: "{{ certificates_list }}"
      loop_control:
        label: "{{ item.name }}"
      when: item.days is defined

    - name: Validate key_size is valid if specified
      ansible.builtin.assert:
        that:
          - item.key_size | int in [2048, 3072, 4096, 8192]
        fail_msg: >-
          Certificate '{{ item.name }}' key_size must be 2048, 3072, 4096, or 8192.
          Current value: '{{ item.key_size }}'
        success_msg: "Certificate '{{ item.name }}' key_size is valid"
        quiet: true
      loop: "{{ certificates_list }}"
      loop_control:
        label: "{{ item.name }}"
      when: item.key_size is defined

    - name: Validate country code is 2 letters if specified
      ansible.builtin.assert:
        that:
          - item.country is string
          - item.country | length == 2
          - item.country is match('^[A-Z]{2}$')
        fail_msg: >-
          Certificate '{{ item.name }}' country must be a 2-letter uppercase code.
          Current value: '{{ item.country }}'
        success_msg: "Certificate '{{ item.name }}' country code is valid"
        quiet: true
      loop: "{{ certificates_list }}"
      loop_control:
        label: "{{ item.name }}"
      when: item.country is defined and item.country | length > 0

    - name: Validate SAN entries if specified
      ansible.builtin.assert:
        that:
          - item.san is iterable
          - item.san is not string
          - item.san is not mapping
        fail_msg: >-
          Certificate '{{ item.name }}' san must be a list.
          Current value: '{{ item.san }}'
        success_msg: "Certificate '{{ item.name }}' SAN list is valid"
        quiet: true
      loop: "{{ certificates_list }}"
      loop_control:
        label: "{{ item.name }}"
      when: item.san is defined

# ============================================================================
# Validation for import mode
# ============================================================================
- name: Validate import mode requirements
  when:
    - certificates_mode == 'import'
    - certificates_list | length > 0
  block:
    - name: Validate cert_src is defined for import certificates
      ansible.builtin.assert:
        that:
          - item.cert_src is defined
          - item.cert_src is string
          - item.cert_src | length > 0
        fail_msg: >-
          Certificate '{{ item.name }}' in import mode must have a 'cert_src' field.
          Current value: '{{ item.cert_src | default("undefined") }}'
        success_msg: "Certificate '{{ item.name }}' has valid cert_src"
        quiet: true
      loop: "{{ certificates_list }}"
      loop_control:
        label: "{{ item.name }}"

    - name: Validate key_src is defined for import certificates
      ansible.builtin.assert:
        that:
          - item.key_src is defined
          - item.key_src is string
          - item.key_src | length > 0
        fail_msg: >-
          Certificate '{{ item.name }}' in import mode must have a 'key_src' field.
          Current value: '{{ item.key_src | default("undefined") }}'
        success_msg: "Certificate '{{ item.name }}' has valid key_src"
        quiet: true
      loop: "{{ certificates_list }}"
      loop_control:
        label: "{{ item.name }}"

    - name: Check if source certificate files exist
      ansible.builtin.stat:
        path: "{{ item.cert_src }}"
      register: certificates_cert_src_stat
      loop: "{{ certificates_list }}"
      loop_control:
        label: "{{ item.name }}"
      delegate_to: localhost
      become: false

    - name: Check if source key files exist
      ansible.builtin.stat:
        path: "{{ item.key_src }}"
      register: certificates_key_src_stat
      loop: "{{ certificates_list }}"
      loop_control:
        label: "{{ item.name }}"
      delegate_to: localhost
      become: false

    - name: Fail if source certificate files don't exist
      ansible.builtin.fail:
        msg: >-
          Source certificate file not found for '{{ item.item.name }}':
          {{ item.item.cert_src }}
      loop: "{{ certificates_cert_src_stat.results }}"
      loop_control:
        label: "{{ item.item.name }}"
      when:
        - not item.stat.exists

    - name: Fail if source key files don't exist
      ansible.builtin.fail:
        msg: >-
          Source key file not found for '{{ item.item.name }}':
          {{ item.item.key_src }}
      loop: "{{ certificates_key_src_stat.results }}"
      loop_control:
        label: "{{ item.item.name }}"
      when:
        - not item.stat.exists

# ============================================================================
# Validation for letsencrypt mode
# ============================================================================
- name: Validate letsencrypt mode requirements
  when:
    - certificates_mode == 'letsencrypt'
    - certificates_list | length > 0
  block:
    # Global certbot configuration validation
    - name: Validate certbot email is defined
      ansible.builtin.assert:
        that:
          - certificates_certbot_email is defined
          - certificates_certbot_email is string
          - certificates_certbot_email | length > 0
          - "'@' in certificates_certbot_email"
        fail_msg: >-
          certificates_certbot_email must be a valid email address for Let's Encrypt registration.
          Current value: '{{ certificates_certbot_email | default("undefined") }}'
        success_msg: "Certbot email is valid"
        quiet: true

    - name: Validate certbot mode is valid
      ansible.builtin.assert:
        that:
          - certificates_certbot_mode is defined
          - certificates_certbot_mode in ['production', 'staging', 'dry-run']
        fail_msg: >-
          certificates_certbot_mode must be one of: production, staging, dry-run.
          Current value: '{{ certificates_certbot_mode | default("undefined") }}'
        success_msg: "Certbot mode is valid: {{ certificates_certbot_mode }}"
        quiet: true

    # Per-certificate validation
    - name: Validate domains field for letsencrypt certificates
      ansible.builtin.assert:
        that:
          - item.domains is defined
          - item.domains is iterable
          - item.domains is not string
          - item.domains is not mapping
          - item.domains | length > 0
        fail_msg: >-
          Certificate '{{ item.name }}' in letsencrypt mode must have a 'domains' list field with at least one domain.
          Current value: '{{ item.domains | default("undefined") }}'
        success_msg: "Certificate '{{ item.name }}' has valid domains list"
        quiet: true
      loop: "{{ certificates_list }}"
      loop_control:
        label: "{{ item.name }}"

    - name: Validate challenge_type is defined for each certificate
      ansible.builtin.assert:
        that:
          - item.challenge_type is defined
          - item.challenge_type in ['http-01', 'dns-01']
        fail_msg: >-
          Certificate '{{ item.name }}' must have challenge_type set to 'http-01' or 'dns-01'.
          Current value: '{{ item.challenge_type | default("undefined") }}'
        success_msg: "Certificate '{{ item.name }}' has valid challenge_type"
        quiet: true
      loop: "{{ certificates_list }}"
      loop_control:
        label: "{{ item.name }}"

    # HTTP-01 specific validation
    - name: Validate HTTP-01 challenge requirements
      ansible.builtin.assert:
        that:
          - item.plugin is defined
          - item.plugin in ['webroot', 'standalone', 'apache', 'nginx']
        fail_msg: >-
          Certificate '{{ item.name }}' with HTTP-01 challenge must have 'plugin' set to one of: webroot, standalone,
          apache, nginx. Current value: '{{ item.plugin | default("undefined") }}'
        success_msg: "Certificate '{{ item.name }}' has valid plugin"
        quiet: true
      loop: "{{ certificates_list }}"
      loop_control:
        label: "{{ item.name }}"
      when: item.challenge_type == 'http-01'

    - name: Validate webroot path for webroot plugin
      ansible.builtin.assert:
        that:
          - item.webroot is defined
          - item.webroot is string
          - item.webroot | length > 0
          - item.webroot is match('^/')
        fail_msg: >-
          Certificate '{{ item.name }}' using webroot plugin must have 'webroot' set to an absolute path.
          Current value: '{{ item.webroot | default("undefined") }}'
        success_msg: "Certificate '{{ item.name }}' has valid webroot path"
        quiet: true
      loop: "{{ certificates_list }}"
      loop_control:
        label: "{{ item.name }}"
      when:
        - item.challenge_type == 'http-01'
        - item.plugin is defined
        - item.plugin == 'webroot'

    # DNS-01 specific validation
    - name: Validate DNS provider is set for DNS-01 challenge
      ansible.builtin.assert:
        that:
          - certificates_certbot_dns_provider is defined
          - certificates_certbot_dns_provider is string
          - certificates_certbot_dns_provider | length > 0
        fail_msg: >-
          certificates_certbot_dns_provider must be set when using dns-01 challenge.
          Current value: '{{ certificates_certbot_dns_provider | default("undefined") }}'
          Example: certificates_certbot_dns_provider: cloudflare
        success_msg: "DNS provider is set: {{ certificates_certbot_dns_provider }}"
        quiet: true
      when: >
        certificates_list
        | selectattr('challenge_type', 'defined')
        | selectattr('challenge_type', 'equalto', 'dns-01')
        | list
        | length > 0

    - name: Validate custom DNS provider hooks
      ansible.builtin.assert:
        that:
          - item.auth_hook is defined
          - item.auth_hook is string
          - item.auth_hook | length > 0
          - item.cleanup_hook is defined
          - item.cleanup_hook is string
          - item.cleanup_hook | length > 0
        fail_msg: >-
          Certificate '{{ item.name }}' with custom DNS provider must have both 'auth_hook' and 'cleanup_hook' defined.
          auth_hook: '{{ item.auth_hook | default("undefined") }}'
          cleanup_hook: '{{ item.cleanup_hook | default("undefined") }}'
        success_msg: "Certificate '{{ item.name }}' has valid custom DNS hooks"
        quiet: true
      loop: "{{ certificates_list }}"
      loop_control:
        label: "{{ item.name }}"
      when:
        - item.challenge_type is defined
        - item.challenge_type == 'dns-01'
        - certificates_certbot_dns_provider == 'custom'

    # Optional fields validation
    - name: Validate deploy_hook path if specified
      ansible.builtin.assert:
        that:
          - item.deploy_hook is string
          - item.deploy_hook | length > 0
        fail_msg: >-
          Certificate '{{ item.name }}' deploy_hook must be a non-empty string.
          Current value: '{{ item.deploy_hook }}'
        success_msg: "Certificate '{{ item.name }}' has valid deploy_hook"
        quiet: true
      loop: "{{ certificates_list }}"
      loop_control:
        label: "{{ item.name }}"
      when:
        - item.deploy_hook is defined

- name: Build validation summary message
  ansible.builtin.set_fact:
    certificates_validation_summary: >-
      {{
        [
          '===================================================================',
          'Certificates Role Validation Summary',
          '===================================================================',
          'Mode: ' + certificates_mode,
          'Certificates to manage: ' + (certificates_list | length | string)
        ] +
        (
          [
            'Certbot mode: ' + certificates_certbot_mode,
            'Certbot email: ' + certificates_certbot_email,
            'Certificate directory: /etc/letsencrypt/live/'
          ] if certificates_mode == 'letsencrypt' else []
        ) +
        (
          [
            'Certificate directory: ' + certificates_cert_dir,
            'Private key directory: ' + certificates_key_dir
          ] if certificates_mode in ['selfsigned', 'import'] else []
        ) +
        [
          '===================================================================',
          'All variable validations passed successfully!',
          '==================================================================='
        ]
      }}

- name: Display validation summary
  ansible.builtin.debug:
    msg: "{{ certificates_validation_summary }}"
